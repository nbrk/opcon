# opcon

A small Haskell library for creating, querying and manipulating echeloned military hierarchies.

A hierarchy is modelled as DAG (Directed Acyclic Graph), with:

- the vertices containing the **user data** (i.e., a unit or some organization)
- the edges being **typed echelon** uplinks to higher headquarters

There are both functional and monadic (state) combinators to work with the hierarchies.


## User data
The user data is abstract, the only requirement is it to be `Eq` (and `Show` if the plotting is considered).

The user data must be an instance of `Organization`:

``` haskell
class (Eq a, Show a) => Organization a where
```

Here is an example data from the `Opcon.Example`:

``` haskell
data Unit
  = Unit
  { unitName :: String
  }
  deriving (Eq, Ord)

-- | Shorter names
instance Show Unit where
  show u = show (unitName u)


instance Organization Unit
```

## Command links
There are two types of echeloned uplink connections: the **organic** and the **OPCON** (Operational Control) 
connections.

1. The organic command means that the sub-organization is a natural (e.g. doctrinal) part of the whole unit (i.e. 1st, 2nd and 3rd fire platoons of a company).
2. The OPCON link means that the sub-organization is attached only temporarily and is not a part of the unit's standard
outfit (i.e. a recon or support unit given to a reinforced battalion).

``` haskell
data Command e
  = Organic e
  | Opcon e
  deriving (Eq)
```

The `e` is the user-defined echelon type, which must be an instance of `EchelonLevel` and, therefore, of `Ord`:

``` haskell
class (Ord e) =>
  EchelonLevel e where
```

Here is an example echelon type from `Opcon.Example`:

``` haskell
data Echelon
  = Team
  | Squad
  | Section
  | Platoon
  | Company
  | Battalion
  | Regiment
  | Brigade
  | Division
  | Corps
  | Army
  | ArmyGroup
  | Theater
  deriving (Eq, Ord)

instance EchelonLevel Echelon
```

## Nodes
Internally, a hierarchy is a synonym:

``` haskell
type Hierarchy a e = DGraph (HierarchyNode a) (Command e)
```

Meaning, that the vertices of the DAG are `HierarchyNode a` and the edges (connections) are of type `Command e`. The 
library deals with possibly equal user-data (for example, while there can't coexist two "equal" platoons in a company, 
they theoretically could coexist in the battalion context) by having a **unique hash** number inside every node.

The drawback is that we need `IO` to conviniently construct new nodes, but the user can do it himself in some other
way if purity is of concern (pure functions are also provided by the library).

### EA ghost-node
Every complete hierarchy has a ghost node called "EA" (for "Echelons Above") which connects to the hierarchy's most
superior HQ, giving him his rank, hence establishing some echelon for the whole hierarchy.

When the library creates, attaches or detaches subhierarchies, it basically tweaks some EA nodes, but you don't
have to worry about it.

Internally, the user data inside `HierarchyNode a` can be either `Just a` or `Nothing`. The latter signifies a ghost node.

## Usage
The API is not steady yet (but the overall concept above seems fine). 

Please see the autogenerated Haddock for the API description.

In the meantime, here is a monadic example (uses `Opcon.Example`):

``` haskell
  h <- startHierarchy $ do
    -- a battalion
    bn <- lift $ genBn "101 Inf. Bn"

    -- working on the battalion from now on
    put bn

    -- a special force company
    co <- lift $ genCoy "SF Coy"

    -- a special platoon
    plt <- mkHierarchyM (mkUnit "ZZ Plt") Platoon [] []

    -- OPCON reinforce the battalion with the company
    attachHierarchyM co False

    -- locate the SF company HQ and reinforce it
    (Just hq) <- findNodeM (\u -> unitName u == "SF Coy")
    attachHierarchyToHqM plt False hq

    -- degrade some elements of the battalion
    hqs <- findAllNodesM (\u -> unitName u == "3rd")
    mapM_ detachHierarchyM hqs


  plotHierarchy h
```
